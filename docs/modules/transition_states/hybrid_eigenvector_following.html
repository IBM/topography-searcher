<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hybrid Eigenvector Following &mdash; topsearch 0.0.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=47de8214"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            topsearch
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">Modules</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">topsearch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Hybrid Eigenvector Following</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/modules/transition_states/hybrid_eigenvector_following.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-topsearch.transition_states.hybrid_eigenvector_following">
<span id="hybrid-eigenvector-following"></span><h1>Hybrid Eigenvector Following<a class="headerlink" href="#module-topsearch.transition_states.hybrid_eigenvector_following" title="Link to this heading"></a></h1>
<p>The single_ended_search module employs different methods for locating
transition states starting from a single point</p>
<dl class="py class">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">topsearch.transition_states.hybrid_eigenvector_following.</span></span><span class="sig-name descname"><span class="pre">HybridEigenvectorFollowing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">potential</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts_conv_crit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts_steps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pushoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steepest_descent_conv_crit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_uphill_step_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_uphill_step_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positive_eigenvalue_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalue_conv_crit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing" title="Link to this definition"></a></dt>
<dd><section id="description">
<h2>Description<a class="headerlink" href="#description" title="Link to this heading"></a></h2>
<p>Class for single-ended transition state searches, starting
from a given position the hybrid eigenvector-following algorithm
is used to take steps uphill until a Hessian index one point is found.
i) Finds eigenvector corresponding to the lowest eigenvalue
ii) Take a step along that eigenvector
iii) Minimise in the remaining subspace
iv) Repeat until convergence</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.potential">
<span class="sig-name descname"><span class="pre">potential</span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.potential" title="Link to this definition"></a></dt>
<dd><p>Function on which we are attempting to find transition states</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>class instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.conv_crit">
<span class="sig-name descname"><span class="pre">conv_crit</span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.conv_crit" title="Link to this definition"></a></dt>
<dd><p>The value the norm of the gradient must be less than before the
transition state is considered converged</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.ts_steps">
<span class="sig-name descname"><span class="pre">ts_steps</span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.ts_steps" title="Link to this definition"></a></dt>
<dd><p>Allowed number of steps before giving up on transition state</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.max_uphill_step_size">
<span class="sig-name descname"><span class="pre">max_uphill_step_size</span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.max_uphill_step_size" title="Link to this definition"></a></dt>
<dd><p>Maximum size of a step that goes in the uphill direction following
the eigenvector corresponding to the negative eigenvalue</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.positive_eigenvalue_step">
<span class="sig-name descname"><span class="pre">positive_eigenvalue_step</span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.positive_eigenvalue_step" title="Link to this definition"></a></dt>
<dd><p>The size of a step along the eigenvector corresponding to the smallest
eigenvalue, when it is still positive</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.pushoff">
<span class="sig-name descname"><span class="pre">pushoff</span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.pushoff" title="Link to this definition"></a></dt>
<dd><p>The size of the displacement along the eigenvector when finding
connected minima for each transition state</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.eig_bounds">
<span class="sig-name descname"><span class="pre">eig_bounds</span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.eig_bounds" title="Link to this definition"></a></dt>
<dd><p>Bounds placed on the eigenvector during minimisation, updated
throughout the search based on the bounds coords is at</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.failure">
<span class="sig-name descname"><span class="pre">failure</span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.failure" title="Link to this definition"></a></dt>
<dd><p>Contains the reason for failure to find a transition state to report</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.remove_trans_rot">
<span class="sig-name descname"><span class="pre">remove_trans_rot</span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.remove_trans_rot" title="Link to this definition"></a></dt>
<dd><p>Flag as to whether to remove eigenvectors that correspond to overall
translation and rotation, needed for atomic and molecular systems</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.analytic_step_size">
<span class="sig-name descname"><span class="pre">analytic_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalue</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.analytic_step_size" title="Link to this definition"></a></dt>
<dd><p>Analytical expression to compute an optimal step length
from coords along eigenvector, given its eigenvalue
Return the appropriate step length in the uphill direction</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.check_eigenvector_direction">
<span class="sig-name descname"><span class="pre">check_eigenvector_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eigenvector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.check_eigenvector_direction" title="Link to this definition"></a></dt>
<dd><p>Check the eigenvector is pointing in the uphill
direction, and if not, flip it so it is</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.check_valid_eigenvector">
<span class="sig-name descname"><span class="pre">check_valid_eigenvector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eigenvector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalue</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.check_valid_eigenvector" title="Link to this definition"></a></dt>
<dd><p>Test that an eigenvector is valid. It cannot contain
only zeros or any nans</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.do_pushoff">
<span class="sig-name descname"><span class="pre">do_pushoff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts_position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">increment</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iteration</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.do_pushoff" title="Link to this definition"></a></dt>
<dd><p>Take a step along the pushoff.
Return the new position after performing pushoff</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.find_pushoff">
<span class="sig-name descname"><span class="pre">find_pushoff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.find_pushoff" title="Link to this definition"></a></dt>
<dd><p>Given the transition state location and direction of its single
negative eigenvalue. We compute a step length in this direction
before beginning a steepest-descent path.
Returns the points to begin steepest-descent paths in the forwards
and backwards direction</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.generate_random_vector">
<span class="sig-name descname"><span class="pre">generate_random_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.generate_random_vector" title="Link to this definition"></a></dt>
<dd><p>Return random uniform vector on sphere</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.get_local_bounds">
<span class="sig-name descname"><span class="pre">get_local_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.get_local_bounds" title="Link to this definition"></a></dt>
<dd><p>Create a box around the given point that ensures that subspace
minimisation is bounded to a small region to avoid moving to
a different basin. Still respect total function bounds</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.get_smallest_eigenvector">
<span class="sig-name descname"><span class="pre">get_smallest_eigenvector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_vector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bounds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bounds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.get_smallest_eigenvector" title="Link to this definition"></a></dt>
<dd><p>Routine to find the smallest eigenvalue and the associated
eigenvector of the Hessian at a given point coords. Method
tests for validity and deals with bounds</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.parallel_component">
<span class="sig-name descname"><span class="pre">parallel_component</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.parallel_component" title="Link to this definition"></a></dt>
<dd><p>Return parallel component of vec1 relative to vec2</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.perpendicular_component">
<span class="sig-name descname"><span class="pre">perpendicular_component</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.perpendicular_component" title="Link to this definition"></a></dt>
<dd><p>Return perpendicular component of vector vec1 relative to vec2</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.project_onto_bounds">
<span class="sig-name descname"><span class="pre">project_onto_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bounds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bounds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.project_onto_bounds" title="Link to this definition"></a></dt>
<dd><p>Project vector back to within the bounds if pointing outside</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.rayleigh_ritz_function_gradient">
<span class="sig-name descname"><span class="pre">rayleigh_ritz_function_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.rayleigh_ritz_function_gradient" title="Link to this definition"></a></dt>
<dd><p>Evaluate the Rayleigh-Ritz ratio to find the value of the
eigenvalue for a given eigenvector vec computed at point
coords, and the gradient with respect to changes in vec</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.remove_zero_eigenvectors">
<span class="sig-name descname"><span class="pre">remove_zero_eigenvectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.remove_zero_eigenvectors" title="Link to this definition"></a></dt>
<dd><p>Make vec orthogonal to eigenvectors of the Hessian corresponding
to overall translations and rotations at given position</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.run" title="Link to this definition"></a></dt>
<dd><p>Perform a single-ended transition state search starting from coords
Returns the information about transition states and their connected
minima that is needed for testing similarity and adding to
stationary point network</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.steepest_descent">
<span class="sig-name descname"><span class="pre">steepest_descent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.steepest_descent" title="Link to this definition"></a></dt>
<dd><p>Perturb away from the transition state along the eigenvector
corresponding to the negative eigenvalue and minimise
to produce the two connected minima and their energies
Returns the coordinates and energy of both connected minima</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.steepest_descent_paths">
<span class="sig-name descname"><span class="pre">steepest_descent_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.steepest_descent_paths" title="Link to this definition"></a></dt>
<dd><p>Perform local minimisation to get the result of a steepest
descent path beginning from position. To avoid very large
initial steps in LBFGS we constrain the local minimisation
into several short steps</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.subspace_function_gradient">
<span class="sig-name descname"><span class="pre">subspace_function_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.subspace_function_gradient" title="Link to this definition"></a></dt>
<dd><p>Return the function value and the component of the gradient
perpendicular to self.eigenvector at point coords</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.subspace_minimisation">
<span class="sig-name descname"><span class="pre">subspace_minimisation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.subspace_minimisation" title="Link to this definition"></a></dt>
<dd><p>Perform minimisation in the subspace orthogonal to eigenvector.
The distance is limited to be at most 1% of the range of the
space to avoid very large initial steps in scipy.lbfgs</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.take_uphill_step">
<span class="sig-name descname"><span class="pre">take_uphill_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvector</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalue</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.take_uphill_step" title="Link to this definition"></a></dt>
<dd><p>Take uphill step of appropriate length given an eigenvector
that defines the step direction, and an eigenvalue that
determines if the step is uphill or not
Return coords after step is taken</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.test_convergence">
<span class="sig-name descname"><span class="pre">test_convergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bounds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bounds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.test_convergence" title="Link to this definition"></a></dt>
<dd><p>Test for convergence accounting for active bounds
Only consider the gradient components in dimensions not at bounds
Return True if points passes convergence test</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.update_eigenvector_bounds">
<span class="sig-name descname"><span class="pre">update_eigenvector_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower_bounds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bounds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#topsearch.transition_states.hybrid_eigenvector_following.HybridEigenvectorFollowing.update_eigenvector_bounds" title="Link to this definition"></a></dt>
<dd><p>Update the bounds on eigenvector to ensure it remains in certain
portion of the sphere that points within the function bounds</p>
</dd></dl>

</section>
</dd></dl>

</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Luke Dicks.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>